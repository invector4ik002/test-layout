html-полезные ссылки:
Мнемоники(элиментики: © знак охраны авторского права = &copy; &#169 итд) https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%B5%D0%BC%D0%BE%D0%BD%D0%B8%D0%BA%D0%B8_%D0%B2_HTML 
Шпоргалка семантические теги: http://front-end.su/2015/11/01/div-or-section-or-article/


css-генераторы для автоматичкского создания кода стилей:
Гениратор в котором можно сделать тени радиусы и цветовые переходы: cssmatic.com
Гениратор в котором можно сделать позиционирование блоков: howtocenterincss.com
Слова, часто используемые в css-классах: https://github.com/yoksel/common-words


//=======================================================================================================================================||
Конспект важное.
//=======================================================================================================================================||

//---------------------------------------------------------------------------------------------------------------------------------------||
Как работает:
POSITION:

Пример:1.
Родительский блок: position: relative; => Дочерний блок: position: adsolute; 
положение дочернего блока не меняется от положения и изменения размеров родителя.

Пример:2.
position: relative; высчитывает начало координат сразу же от родительского блока!
Побочные эффекты: Если* внутри блока больше одного блока с одинаковыми координатами то они не встанут друг на друга а сьедут
для размещения в таком случае нужно использовать Пример:1.(тогда блоки с одинаковыми координатами наложаться друг на друга).
Можно использовать z-index в такой связке что бы менять расположение блоков один над другим (больше цифра выше блок или блочный элемент).

Пример:3.
position: fixed; фиксирует блок не зависимо то окружающего контента Пример меню которое при прокрутке сайта стоит на месте.
Если* добавляются блоки которые ниже в коде html они имеют z-index выше и будут наезжать на (фиксированное меню) тогда нужно задать
z-index что бы z-index меню всегда был выше чем у астольных блоков сайта!
Внимание! position: нужно использовать как можно реже при верстке испольовать его для фиксации например меню эконок социальных сетей 
или дикораций например подвал в котором есть эконезированные ссылки на соц сети итд.

box-sizing: border-box; говорит о том что в блочную модель не будут входить padding и рамки. 
Если* "дочерниму" контейнеру задаем ширину 100% а "родитель" при этом имеет например width: 1280px; то по идеи логически мы ждем
,что и "дочерний" будет такойже ширины,НО! при добавлении "дочерниму" padding например 50px для внутреннего стеснения то padding
плюсуется к общей величине и размер дочернего станет 1380! что бы этого избежать есть замечательное св-во box-sizing с методом
border-box; !!!


    Важно! *Убираем margin у всех элементов в верстке в ИНДИВИДУАЛЬНОМ порядке! 
    Подход с универсальным селектором *{...} может дать сбой,не допустимо!

    Важно! *Если мы хотим сказать блоку что-бы высота задавалась по содержимому несмотря на элементы внутри блока со стилями 
    float: left или float: right; . Берем его class=".class" и используем псевдоэлемент! 
    .class:after { // after-идущий после.
       content: "";
       display: block;
       width: 100%;
       clear: both;
    } Заметка* этот подход используется ОЧЕНЬ ЧАСТО в веб-разработке!
    
    Важно! *Ели используем выравнивание element в блоке по средству margin-top:(как правильно это margin:1 0 0 0) или 
    margin-position:(как правильно это margin:0 0 1 0). то ИСПОЛЬЗУЕМ один метод для всех элементов!

//---------------------------------------------------------------------------------------------------------------------------------------||

//=======================================================================================================================================||
Разбор первого блока.
Несмотря на симатику первым создается <div class="container"></div> с классом в котором задоется основа глобалного размера и центровка.
.container {
    width: 1900px; например.
    margin: 0 auto; центровка.
    outline: 1px solid black; обводка для удобства работы (потом убирается).
} 
Работа со списком,детали:
Добавление няшек перед списком(галочки качаем с макета): используем псевдоэлемент :before-идущий перед.
Пример:
.main-header-list li:before {// before-идущий перед в нашем случае перед li
    content: "";
    display: block; что бы двигать должен быть блочным,теперь можно завести размеры.
    width: 25px;
    height: 19px;
    outline: 1px solid black; для наглядности.
    position: absolute;// Теперь открыт доступ к включению расположения элемента.Родителю задаем position: relative;
    top: ;             // Родителем является все что стоит перед .main-header-list li:before то есть .main-header-list li
    left: ;
}

//========================================================================================================================================||
FLEX-BOX 
//========================================================================================================================================||
Задачи:Разобрать,понять,полюбить =)

РОДИТЕЛЬСКОЕ ВСОЙСТВО!

display: flex; // дисплей: гибкий;
1) Первое,что делается обьявляется Родительскому контейнеру (блочный элемент) задается свойство!
   Оно распространяется по всем дочерним элементам,высший порядок иерархии.

.container { ------> Какой то родительский блок.

  display: flex; /* or inline-flex */

}
//---------------------------------------------------------------------------------------------------------------------------------------------------------|

РОДИТЕЛЬСКОЕ ВСОЙСТВО!

display-direction: // Дисплей-направления: Тоесть все что в родителе теперь имеет направление!
2) *Важно! Второе что делается задается вектор направления всем дочерним блокам!
    все последующие действия(расположения) идут от ВЕКТОРОВ
     row-горизантальное расположение 
     column-вертикальное расположение 
    Свойства:
    1) row; // строка,то есть горизантальный оброз. дефоултное значение (ставится само если затупил) 
      напровление стандарт слева на право.
    2) row-reverse // зеркальное расположение.
    3) column  // колонка,расположение: вертикаль,значение сверху вниз!
       column-reverse; // колонка,расположение: вертикаль,значение снизу вниз!
//----------------------------------------------------------------------------------------------------------------------------------------------------------|

РОДИТЕЛЬСКОЕ ВСОЙСТВО!

justify-content: // обосновывать-содержание: Выравнивает элементы по главной оси. Задали display-direction: row; пляшем горизонтально! как вариант 
   Как я понял что это ОБОСНОВЫВАТЬ понимается как типа "приехали сюда и обосновались".
   уместились,обустроились итд. содержание имеется ввиду *Дочерних элементов! 
Свойства:
   1) flex-start; - дефолтное значение (ставится само если затупил) поведение элементов: прижимаются влево.*плотоно между собой "0px" (свободное место с права)
   2) flex-end;   - поведение элементов: прижимаются вправо.*плотоно между собой "0px"(свободное место слева)
   3) center;     - поведение элементов: встоют по центру.*плотоно между собой "0px"(свободное место с обоих сторон)
   4) space-between;// Пространство между ними; - повевдение элементов: крайние элементы прилепают к левому и правому краю Родителя
    все что между ними втанет ровно разделяя свободное пространство поровну.
   5) space-around;// Пространство вокруг; - повевдение элементов: крайние пространства звнимают половину от пространства между остальными.
   ^и все это похоже адоптивнo^
   6) spaсe-evenly;// Пространственно-равномерно; - повевдение элементов: все свободное пространство ровномерно вокруг элементов.
//----------------------------------------------------------------------------------------------------------------------------------------------------------|

РОДИТЕЛЬСКОЕ ВСОЙСТВО!

align-items: // выравнивать-элементы: выравнивание элементов по второстепенной оси ВЕРТИКАЛЬНО от заданного ГОРИЗОНТАЛЬНО (row) вектора.
Свойства:
   1) stretch; - растянет элементы от верха к низу во всю высоту. дефоултное значение (ставится само если затупил) *если есть min-width / max-width.
   2) center; - поведение элементов: выравнивает элементы по вертикали по центру если у блока есть *заданная высота*.
   3) flex-end; - поведение элементов: элементы вплотную ложаться на низ блока *Родителя!
   4) flex-start; - поведение элементов: элементы вплотную прижимаются к верху блока *Родителя!
   5) baseline; - элементы выровнены, такие как их базовые линии например текст внутри блока.
//----------------------------------------------------------------------------------------------------------------------------------------------------------|

РОДИТЕЛЬСКОЕ ВСОЙСТВО!

flex-wrap: // гибкое-обертывание: При сжатии Родительского контейнера элементы смещаются сохраняя свои размеры. 
Свойства:
   1) nowrap; - поведение элементов: переноса не будет переноса нет =). дефоултное значение (ставится само если затупил) 
   2) wrap; - поведение элементов: ну собственно перенос. 
    Сапорт свойство:
   *! align-content: // выравнивать-контента: Я бы назвал УПРАВЛЕНИЕ ВСЕМИ ЭЛЕМЕНТАМИ ПОСЛЕ СРАБАТЫВАНИЯ ПЕРЕНОСА!
      Свойства:
       1) center; - собирает все элементы в кучу в центре parent контейнера СОХРАНЯЯ НАПРИМЕР ВЫШЕ ЗАДАННЫЕ СВОЙСВА ПО РАССТОЯНИЯМ МЕЖДУ НИМИ с краев свободно!
           все что есть =)
       2) space-between; - то что переносится ляжет соответственно свойству прижмется к кроям левому и правому сохраняя ровное пространство между остальными
          *Заметка - если перенесется один элемент он тупо прилипнет в нижний левый угол ожидая следующий элемент что бы поделиться свободным местом! вот =)
       3) space-around; - то что переносится прижмется к левому краю так как свойство выше row-строка.Но будут иметь половину пространства сверху и снизу
           то пространства между ними но уже по вертикали так как подключено свойство flex-wrap НУ ТУТ И НЕ СТЫДНО СДЕЛАТЬ ВЫВОД flex-wrap переключатель на ВЕРТИКАЛЬ =)
           при смещении - жесть =) карты таро блин =).
       4) flex-start; - верхний левый угол. с отступами между элементами естессено.
       5) flex-end; - нижний левый угол. с отступами между элементами естессено.

//=========================================================================================================================||
Такс препроцессоры =)
//================================================================================================================================================================||      
Что есть в препроцесорах:


1) Переменные:
   Способ обьявления: @whdth: 1000px; // 
      "@"-обьявление переменной. 
      "whdth:"-название переменной (можент быть любым но по смыслу предназначения). 
      1000px;-заданная ширина.
   Переменные могут быть *Двух видов!
     1) Глобальная которая указывется вне скобок стилей (ее можно указывать во всех кубиках кода стилей)
       Пример: 
       @whdth: 1000px;
       .buy-lux-list {
            width: @whdth;
            float: left;
            height: 274px;               
         }
     2) Локальная которая и указывается в том же кубике кода стилей.
         Пример:
         .buy-lux-list {
            @whdth: 1000px;
            width: @whdth;
            float: left;
            height: 274px;               
         }    
*Так же пере к переменным можно применять операторы такие как "-" "+" "/" "*" .
  Примечание: перед применением оператора вычитания переменную следует обернуть в скобки.
    Пример:
     (@whdth)-10 Что отобразится в CSS как значение св-ва 990px; .
*Так же назначаем к переменным цвета!
   Пример:
    @p-color: red; - цвет текста у ссылки.
    @link-color: red; - цвет текста у ссылки.
    @link-color-hover: red; - цвет принаведении.
    @link-color-active: red; - итд

//========================================================================================================================================================||
Умеем вложености Вроде умеем вроде практикуем!
//========================================================================================================================================================||

//========================================================================================================================================================||
Амперсант! "&"
  Интрумен помогающий избежать последовательного наложения слассов и тегов или атрибутов(тут хз) в CSS.
  Пример: 
  Этот пример показывает компиляцию как CSS собирает вложеность и вроде это не очень хорошо!

    body .container .contacts-footer .contacts-section .contacts-wrapper .contacts-list {
  margin: 8px 0 0 0;
  list-style-type: none;
  padding: 0 0 0 0;
}
  Это происходит в результате вложенности в Less. избижать такого позволит амперсант.
  добавляя его вместо ГЛАВНОГО ТЕМАТИЧЕСКОГО НАЗВАНИЯ КЛАСС ТОЧНЕЕ ЕГО НАЧАЛА.
  Пример:
  .contacts-footer .contacts-section .contacts-wrapper .contacts-list
  &-footer &-section &-wrapper &-list
  Как это в Less               Как это в CSS
 //                      |   .prices {
 //                      |        width: 100px;
 }                       |  }
  .prices {              |  .prices.prices-title {
     width: 100px;       |      display: block;
     .prices-title {     |  }
        display: block;  |
     }                   |
  } 
Добавим омперсант в дочерний И!

.prices {               
     width: 100px;       
     &-title {      
        display: block;  
     }                   
  }
И CSS отоброзит как новый со своим классом кубик стилей.( коряво для чтение кому то но это мне=) )



